---
layout: post
title: "Summer of Code 2012 - Line placements and font sets"
author: Hermann Kraus
---



Building on my work from [last week](http://mapnik.org/news/2012/08/04/gsoc2012-status7)
I completed serval smaller tasks this week. While each task on its own was not
very big together they have lead to a state where almost all tests pass!

# Collision detection
The most important part was implementing collision detection for line placements.

First a short description of the old code:

* Calculate position of glyph
* Store position
* Repeat until all characters are processed
* Calculate bounding box (requires a lot of the same calculations already done
  for the position again)
* Check for collision
* Store bounding box
* Repeat for all characters
* Updated detector with stored bounding boxes

As one can see this is not very efficient.

The new code therfore does this:

* Calculate position of glyph
* Store position
* Calculate bounding box (using the already computed values)
* Check for collision
* Store bounding box
* Repeat for all characters
* Updated detector with stored bounding boxes

This has two advantages:

* Calculations don't have to be done a second time
* If there is a collision processing is aborted instead of wasting time on all
  following characters

The new detector therefore should be a bit faster in the average case
and much faster when there are lots of collisions.

# Label position tolerance
This property was very easy to implement, but I think the behavior it is done is
not very efficient. When a placement can't be made at the intended place up to
200(!) slightly different places are tried. This usually means moving the text
one pixel and trying again. I think the displacement should grow exponentially.
So instead of trying +-1, +-2, +-3, +-4, +-5,... try +-1, +-2, +-4, +-8, +-16, ...
This would bring a huge increase in performance.


# Offseted lines
First I implemented support for displacement along the line. This allows you to
render text offseted from the center of the line.
Then I also implemented displacement perpendicular to the line. However I did
not use the algorithm for the old code but instead I produce true offsets.
The difference can be seen in this picture:

![text offseted](/images/harfbuzz/line-offset.png)

With the old code text touches the line while it keeps the distance perfectly
with the new code.
Here is an example showing that it also works well with complex scripts:

![Khmer text offseted](/images/harfbuzz/offseted.png)

# Multi line labels
This also allowed me to implement multi line labels very efficiently. One can
use the same functions for point and line placements now
("jalign", "wrap-width", "wrap-before", embedded newline characters).

Example:
![multi line text](/images/harfbuzz/multiline.png)

As one can see sometimes the placement is not perfect, but this only happens
for very rare cases (zig-zag-pattern), more common cases (straight lines, circles)
are handled correctly. The problem is that there is currently no function to
map a point on the original line to the offseted line in offset_converter.


# Performance tweaks
Profiler output for old versions of Mapnik has shown that a lot of the time spent
for text rendering in trigonometric functions (sin, cos, atan2). So instead
of calculation theses values several times (IIRC the old code calculated them
at least 5 times per character) I store them after the first calculation. I think
even this one calculation could be removed but it would complicate some other
things (determining which characters are upside down) so I'm waiting for data
saying it is really necessary before doing it.

# Grid renderer
As the API is stable now I also reenabled support for grid renderer.

# Next steps
Only one big thing is left:

* Add support for ShieldSymbolizer